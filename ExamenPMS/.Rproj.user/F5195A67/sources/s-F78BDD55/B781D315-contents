---
  title: "tp MNB"
output: pdf_document
---

```{python}
def oui(L):
  L.append(1)
```

```{python}
L=[]
oui(L)
print(L)
```

<!-- ### Question 1 : -->

Soit $x_1$ et $x_2$ solutions respectivement de (1) et (2),

$\frac{dH}{dt} = \frac{d}{dt} (\frac{v_1^2}{2} + \frac{v_1^2}{2} + \frac{2}{5} (x_1 - x_2)_{+}^{5/2})$

$\frac{dH}{dt} = \frac{d}{dt} (\frac{v_1^2}{2}) + \frac{d}{dt} (\frac{v_1^2}{2}) + \frac{2}{5} \frac{d}{dt} (x_1 - x_2)_{+}^{5/2})$

$\frac{dH}{dt} = v_1 \frac{dv_1}{dt}  +  v_2 \frac{dv_2}{dt}+ (\frac{dx_1}{dt} - \frac{dx_2}{dt} )(x_1 - x_2)_{+}^{3/2}$

$\frac{dH}{dt} = v_1 \frac{d²x_1}{dt}  +  v_2 \frac{d^2x_2}{dt}+ (\frac{dx_1}{dt} - \frac{dx_2}{dt} )(x_1 - x_2)_{+}^{3/2}$

En utilisant le fait que $x_1$ et $x_2$ sont solutions de (1) et (2);

$\frac{dH}{dt} = -v_1 (x_1 - x_2)_{+}^{3/2} +  v_2 (x_1 - x_2)_{+}^{3/2} + (v_1 - v_2 )(x_1 - x_2)_{+}^{3/2}$

En développant on trouve bien;

$\frac{dH}{dt} = 0$

### Question 2 :

En utilisant la relation $\frac{dY}{dt} = F(Y)$ et ebn procédant par identification on obitent: 

$F_1(Y) =  v_1$
$F_2(Y) =  v_2$
$F_3(Y) =  -(x_1 - x_2)_{+}^{3/2}$
$F_4(Y) =  (x_1 - x_2)_{+}^{3/2}$

### Question 3 :

```{python}
def euler_explicite(y0, T, h):
    Y = []
    N = T/h
    Y.append(y0)

    for j in range(1, N+1):
        prec = Y[-1]
        a = prec[0] + h * prec[2]
        b = prec[1] + h * prec[3]
        c = prec[2] - h * (prec[0]-prec[1])**3/2
        d = prec[3] + h * (prec[0]-prec[1])**3/2

        Y.append([a, b, c, d])
    return Y
    
euler_explicite(3, 0.5)
```


### Question 4 :

Modélisation du problème en python : 

Cas où $h = 10^{-1}$

```{python}
T = 4
Res = euler_explicite([0, 0, 1, 0], 10**(-1))

X = np.linspace(0, 4, 41)
X1 = []
X2 = []
Y1 = []
Y2 = []


for i in range(len(Res)):
    X1.append(Res[i][0])
    X2.append(Res[i][1])
    Y1.append(Res[i][2])
    Y2.append(Res[i][3])
    

plt.plot(X, X1)
plt.plot(X, X2)
plt.plot(X, Y1)
plt.plot(X, Y2)
plt.show()
```

Cas où $h = 10^{-2}$

```{python}
T = 4
Res = euler([0, 0, 1, 0], 10**(-2))

X = np.linspace(0, 4, 401)
X1 = []
X2 = []
Y1 = []
Y2 = []


for i in range(len(Res)):
    X1.append(Res[i][0])
    X2.append(Res[i][1])
    Y1.append(Res[i][2])
    Y2.append(Res[i][3])
    

plt.plot(X, X1)
plt.plot(X, X2)
plt.plot(X, Y1)
plt.plot(X, Y2)
plt.show()
```


Cas où $h = 10^{-3}$
```{python}
T = 4
Res = euler([0, 0, 1, 0], 10**(-3))

X = np.linspace(0, 4, 4001)
X1 = []
X2 = []
Y1 = []
Y2 = []


for i in range(len(Res)):
    X1.append(Res[i][0])
    X2.append(Res[i][1])
    Y1.append(Res[i][2])
    Y2.append(Res[i][3])
    

plt.plot(X, X1)
plt.plot(X, X2)
plt.plot(X, Y1)
plt.plot(X, Y2)
plt.show()
```

Commentaires à faire.

### Question 5 :

Trouvons deux matrices A et B correspondant aux critères de l'énoncé. En travaillant par identification on trouve.

$ A = M + h^2 D$ où $M = \begin{bmatrix} m_1 & 0& ...& 0& 0  \\ &&... \\ 0 & 0 & m_i & 0 &0 & \\ &&... \\ 0 & 0 &... &0 & m_n\end{bmatrix}$ M étant diagonale et  $D = \begin{bmatrix} 1 & -1 & ...&...& 0  \\ -1 & 2& -1&0& 0  \\ &&...  \\0 & 0 & -1&2& -1  \\0 & 0& ...&-1& 2 \\\end{bmatrix}$
2u_1^{(k)}-u_1^{(k-1)} + h^2 f_1((k+1)h)
2u_n^{(k)}-u_n^{(k-1)}
De même on obtient $b^{(k)} = \begin{bmatrix} 2u_1^{(k)}-u_1^{(k-1)} + h^2 f_1((k+1)h)  \\ 2u_2^{(k)}-u_2^{(k-1)} \\ ... \\ 2u_{n-1}^{(k)}-u_{n-1}^{(k-1)} \\ 2u_n^{(k)}-u_n^{(k-1)}\end{bmatrix}$

### Question 6 :

$A \in S_n(\mathbb{R})$ car $S_n(\mathbb{R})$ est un espace vectoriel donc comme $(D,M) \in S_n(\mathbb{R})^2$ alors $A \in S_n(\mathbb{R})$

Soit $X \in M_{n,1}(\mathbb{R})$,

A finir

### Question 7 :

```{python}
def factorise(ainf, adiag):
  n = len(adiag)
  linf; ldiag = [0]*(n-1); [0]*n
  for i in range(n):
    if i == 0 :
      ldiag[i] = np.sqrt(adiag[i])
    else:
      ldiag[i] = np.sqrt(adiag[i])
      linf[i-1] = ainf[i-1]*np.sqrt(adiag[i-1])
      
  return ldiag, linf
```

### Question 8 :

```{python}
def descente(linf, ldiag, b):
  n = len(b)
  y = [0]*n
  for i in range(n):
    if i == 0 :
      y[i] = b[0]/ldiag[0]
    else:
      y[i] = (b[i] - y[i-1]*linf[i])/ldiag[i]
      
  return y
```

### Question 9 :

```{python}
def remonte(linf, ldiag, y):
  n = len(y)
  u = [0]*n
  for i in range(n):
    if i == 0 :
      u[n] = y[n]/ldiag[n]
    else:
      u[n-i] = (y[n-i] - u[n-i+1]*linf[n-i])/ldiag[n-i]
      
  return u
```

### Question 10 :

```{python}
def solution_numerique(val_initial1, val_initiale2) :
  #On met la suite des u(k) dans U dans l'ordre en commençant par l'indice u(-1)
  U = [val_initial1, val_initiale2]
  #On met la suite des b(k) dans B dans l'ordre en commençant par l'indice b(0)
  B = []
  factorise(ainf, adiag)
  
```




